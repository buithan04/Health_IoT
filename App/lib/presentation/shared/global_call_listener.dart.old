import 'dart:async';
import 'package:flutter/material.dart';
import 'package:app_iot/service/socket_service.dart';
import 'package:app_iot/service/webrtc_service.dart';
import 'package:app_iot/presentation/shared/webrtc_call_screen.dart';
import 'package:app_iot/presentation/shared/incoming_call_dialog.dart';
import 'package:app_iot/main.dart'; // For navigatorKey

/// Global WebRTC Call Listener
/// L·∫Øng nghe incoming calls ·ªü m·ªçi m√†n h√¨nh trong app
class GlobalCallListener extends StatefulWidget {
  final Widget child;
  
  const GlobalCallListener({
    Key? key,
    required this.child,
  }) : super(key: key);

  @override
  State<GlobalCallListener> createState() => _GlobalCallListenerState();
}

class _GlobalCallListenerState extends State<GlobalCallListener> {
  final SocketService _socketService = SocketService();
  StreamSubscription? _offerSubscription;
  StreamSubscription? _iceCandidateSubscription;
  StreamSubscription? _callEndedSubscription;
  
  // Track active incoming call to prevent duplicates
  String? _activeIncomingCallerId;
  bool _hasActiveDialog = false;

  @override
  void initState() {
    super.initState();
    _setupGlobalCallListeners();
  }

  void _setupGlobalCallListeners() {
    print('üåê [GLOBAL] Setting up global call listeners...');
    
    // Listen for incoming call offers (GLOBAL - works everywhere)
    _offerSubscription = _socketService.webrtcOfferStream.listen((data) {
      if (!mounted) return;
      
      final fromUserId = data['from']?.toString() ?? '';
      final fromName = data['fromName']?.toString() ?? 'Ng∆∞·ªùi d√πng';
      final fromAvatar = data['fromAvatar']?.toString();
      final offer = data['offer'] as Map<String, dynamic>?;

      if (offer == null || fromUserId.isEmpty) {
        print('‚ö†Ô∏è [GLOBAL] Invalid offer data received');
        return;
      }
      
      // Prevent duplicate dialogs - check multiple conditions
      if (_hasActiveDialog && _activeIncomingCallerId == fromUserId) {
        print('‚ö†Ô∏è [GLOBAL] Already showing dialog for $fromUserId, ignoring duplicate');
        return;
      }
      
      // Prevent if already in any call
      if (WebRTCService().isCallActive) {
        print('‚ö†Ô∏è [GLOBAL] Already in a call, ignoring new incoming call');
        return;
      }

      print('\nüìû [GLOBAL] ‚ïê‚ïê‚ïê INCOMING CALL OFFER ‚ïê‚ïê‚ïê');
      print('   From User ID: $fromUserId');
      print('   From Name: $fromName');
      print('   Context mounted: $mounted');
      print('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
      
      // Mark as active
      _activeIncomingCallerId = fromUserId;
      _hasActiveDialog = true;

      // Show incoming call dialog (full screen overlay)
      _showGlobalIncomingCallDialog(
        fromUserId: fromUserId,
        fromName: fromName,
        fromAvatar: fromAvatar,
        offer: offer,
      );
    });

    // NOTE: Answer handling is done in WebRTCService's internal listener
    // to prevent duplicate processing and ensure proper state management

    // Listen for ICE candidates
    _iceCandidateSubscription = _socketService.webrtcIceCandidateStream.listen((data) {
      final candidate = data['candidate'] as Map<String, dynamic>?;
      if (candidate != null) {
        WebRTCService().handleIceCandidate(candidate);
      }
    });

    // Listen for call ended
    _callEndedSubscription = _socketService.callRejectedStream.listen((data) {
      final reason = data['reason']?.toString() ?? 'ended';
      print('üì¥ [GLOBAL] Call ended/rejected - Reason: $reason');
      
      // Dismiss incoming call dialog if active
      if (_hasActiveDialog) {
        final navContext = navigatorKey.currentContext;
        if (navContext != null) {
          Navigator.of(navContext, rootNavigator: true).popUntil((route) {
            // Pop until we're not in a dialog
            return !route.toString().contains('DialogRoute');
          });
        }
        _hasActiveDialog = false;
        _activeIncomingCallerId = null;
      }
      
      // Delay cleanup to let outgoing_call_screen handle dismissal first
      Future.delayed(const Duration(milliseconds: 200), () {
        // End call on WebRTC service side (if not already ended)
        if (WebRTCService().isCallActive) {
          WebRTCService().endCall(sendNotification: false);
        }
      });
      
      if (mounted) {
        // Show different messages based on reason
        String message;
        switch (reason) {
          case 'timeout':
            message = '‚è±Ô∏è Kh√¥ng c√≥ ph·∫£n h·ªìi';
            break;
          case 'rejected':
            message = '‚ùå Cu·ªôc g·ªçi b·ªã t·ª´ ch·ªëi';
            break;
          case 'cancelled':
            message = 'üì¥ Cu·ªôc g·ªçi ƒë√£ b·ªã h·ªßy';
            break;
          default:
            message = 'üì¥ Cu·ªôc g·ªçi ƒë√£ k·∫øt th√∫c';
        }
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(message),
            duration: Duration(seconds: 2),
          ),
        );
      }
    });

    print('‚úÖ [GLOBAL] Global call listeners setup complete');
  }

  void _showGlobalIncomingCallDialog({
    required String fromUserId,
    required String fromName,
    String? fromAvatar,
    required Map<String, dynamic> offer,
  }) {
    // Use global navigatorKey to show dialog
    final context = navigatorKey.currentContext;
    if (context == null) {
      print('‚ùå [GLOBAL] No navigator context available');
      return;
    }

    showIncomingCallDialog(
      context: context,
      callerName: fromName,
      callerAvatar: fromAvatar,
      onAccept: () async {
        print('‚úÖ [GLOBAL] User accepted call from $fromUserId');
        
        // Dialog will be closed by showIncomingCallDialog's onAccept callback
        // Don't pop here to avoid double-pop error
        
        // Clear dialog tracking
        _hasActiveDialog = false;
        _activeIncomingCallerId = null;
        
        try {
          // Accept the call
          print('üìû [GLOBAL] Calling acceptCall()...');
          final success = await WebRTCService().acceptCall(
            offer: offer,
            callerUserId: fromUserId,
            callerUserName: fromName,
            callerUserAvatar: fromAvatar,
          );

          print('üìû [GLOBAL] acceptCall() returned: $success');

          if (success) {
            // Navigate to call screen after dialog is closed
            final currentContext = navigatorKey.currentContext;
            if (currentContext != null) {
              print('‚úÖ [GLOBAL] Navigating to call screen...');
              Navigator.of(currentContext).push(
                MaterialPageRoute(
                  builder: (_) => WebRTCCallScreen(
                    remoteUserId: fromUserId,
                    remoteUserName: fromName,
                    remoteUserAvatar: fromAvatar,
                    isOutgoingCall: false,
                  ),
                ),
              );
            } else {
              print('‚ùå [GLOBAL] Navigator context is null');
            }
          } else {
            print('‚ùå [GLOBAL] Failed to accept call');
            final currentContext = navigatorKey.currentContext;
            if (currentContext != null) {
              ScaffoldMessenger.of(currentContext).showSnackBar(
                const SnackBar(content: Text('‚ùå Kh√¥ng th·ªÉ nh·∫≠n cu·ªôc g·ªçi. Ki·ªÉm tra quy·ªÅn camera/mic.')),
              );
            }
          }
        } catch (e, stackTrace) {
          print('‚ùå [GLOBAL] Error accepting call: $e');
          print('   Stack trace: $stackTrace');
          final currentContext = navigatorKey.currentContext;
          if (currentContext != null) {
            ScaffoldMessenger.of(currentContext).showSnackBar(
              SnackBar(content: Text('‚ùå L·ªói: ${e.toString()}')),
            );
          }
        }
      },
      onDecline: () async {
        print('‚ùå [GLOBAL] User declined call from $fromUserId');
        
        // Clear dialog tracking
        _hasActiveDialog = false;
        _activeIncomingCallerId = null;
        
        await WebRTCService().rejectCall(fromUserId);
      },
    );
  }

  @override
  void dispose() {
    print('üõë [GLOBAL] Disposing global call listeners');
    _offerSubscription?.cancel();
    _iceCandidateSubscription?.cancel();
    _callEndedSubscription?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}
