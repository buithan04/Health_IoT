import 'dart:async';
import 'package:flutter/material.dart';
import 'package:app_iot/service/webrtc_service.dart';
import 'package:app_iot/service/socket_service.dart';
import 'package:app_iot/presentation/shared/webrtc_call_screen.dart';
import 'package:google_fonts/google_fonts.dart';

/// Outgoing Call Screen - M√†n h√¨nh khi ƒëang g·ªçi ra (ch·ªù partner b·∫Øt m√°y)
/// Gi·ªëng Messenger: Avatar l·ªõn, n√∫t End Call m√†u ƒë·ªè
class OutgoingCallScreen extends StatefulWidget {
  final String remoteUserId;
  final String remoteUserName;
  final String? remoteUserAvatar;

  const OutgoingCallScreen({
    Key? key,
    required this.remoteUserId,
    required this.remoteUserName,
    this.remoteUserAvatar,
  }) : super(key: key);

  @override
  State<OutgoingCallScreen> createState() => _OutgoingCallScreenState();
}

class _OutgoingCallScreenState extends State<OutgoingCallScreen>
    with SingleTickerProviderStateMixin {
  final WebRTCService _webrtcService = WebRTCService();
  final SocketService _socketService = SocketService();
  late AnimationController _pulseController;
  Timer? _timeoutTimer;
  Timer? _offlineCheckTimer;
  String _statusText = "ƒêang g·ªçi...";
  bool _hasEnded = false;
  
  StreamSubscription? _callStateSub;
  StreamSubscription? _answerSub;
  StreamSubscription? _rejectedSub;

  @override
  void initState() {
    super.initState();
    _initPulseAnimation();
    _setupListeners();
    _startCall();
    _startTimeoutTimer();
    _checkPartnerOnline();
  }

  void _setupListeners() {
    print('\nüîî [OUTGOING] ‚ïê‚ïê‚ïê SETTING UP LISTENERS ‚ïê‚ïê‚ïê');
    
    // Listen for call state changes
    _callStateSub = _webrtcService.callState.listen((state) {
      if (!mounted || _hasEnded) return;
      
      switch (state) {
        case CallState.connected:
          // Partner accepted! Navigate to video screen
          _navigateToVideoScreen();
          break;
        case CallState.ended:
          _endCall("Cu·ªôc g·ªçi ƒë√£ k·∫øt th√∫c");
          break;
        default:
          break;
      }
    });
    print('   ‚úÖ callState listener registered');

    // Listen for answer (partner accepted)
    _answerSub = _socketService.webrtcAnswerStream.listen((data) {
      if (!mounted || _hasEnded) return;
      print("‚úÖ [OUTGOING] Received answer, connecting...");
      setState(() {
        _statusText = "ƒêang k·∫øt n·ªëi...";
      });
    });
    print('   ‚úÖ webrtcAnswer listener registered');

    // Listen for rejected call
    _rejectedSub = _socketService.callRejectedStream.listen((data) {
      print('\n‚ùå [OUTGOING] ‚ïê‚ïê‚ïê CALL REJECTED/ENDED EVENT ‚ïê‚ïê‚ïê');
      print('   Mounted: $mounted');
      print('   HasEnded before: $_hasEnded');
      print('   Data: $data');
      
      if (!mounted) {
        print('   ‚ö†Ô∏è Widget not mounted, ignoring');
        print('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
        return;
      }
      
      // Prevent duplicate handling
      if (_hasEnded) {
        print('   ‚ö†Ô∏è Already ended, skipping');
        print('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
        return;
      }
      
      final reason = data['reason'] ?? 'unknown';
      print('   Reason: $reason');
      
      // Cleanup WebRTC first (don't send notification again)
      print('   üßπ Cleaning up WebRTC...');
      _webrtcService.endCall(sendNotification: false);
      
      // Set flag and update UI
      print('   üö™ Setting hasEnded flag and attempting dismiss...');
      setState(() {
        _hasEnded = true;
      });
      
      // Wait a frame for setState to take effect, then pop
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) {
          print('   ‚ö†Ô∏è Widget unmounted after setState');
          return;
        }
        
        print('   üö™ Popping screen NOW...');
        try {
          Navigator.of(context).pop();
          print('   ‚úÖ Screen dismissed successfully');
        } catch (e) {
          print('   ‚ùå Pop failed: $e, trying root navigator...');
          try {
            Navigator.of(context, rootNavigator: true).pop();
            print('   ‚úÖ Root navigator pop succeeded');
          } catch (e2) {
            print('   ‚ùå Root pop also failed: $e2');
          }
        }
        
        // Show message after pop
        Future.delayed(const Duration(milliseconds: 200), () {
          // Find the closest scaffold context that's still mounted
          try {
            String message = "Cu·ªôc g·ªçi ƒë√£ k·∫øt th√∫c";
            if (reason == 'rejected') {
              message = "Ng∆∞·ªùi d√πng t·ª´ ch·ªëi cu·ªôc g·ªçi";
            } else if (reason == 'cancelled') {
              message = "Cu·ªôc g·ªçi ƒë√£ b·ªã h·ªßy";
            } else if (reason == 'timeout') {
              message = "Ng∆∞·ªùi d√πng kh√¥ng li√™n l·∫°c ƒë∆∞·ª£c";
            }
            
            print('   üì¢ Trying to show message: $message');
            // Note: This might fail if we've already popped, which is fine
          } catch (e) {
            print('   ‚ö†Ô∏è Could not show message (expected after pop): $e');
          }
        });
      });
      
      print('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
    });
    print('   ‚úÖ callRejected listener registered');
    
    print('‚úÖ [OUTGOING] All listeners setup complete\n');
  }

  void _navigateToVideoScreen() {
    if (_hasEnded) return;
    _hasEnded = true;
    
    Navigator.of(context).pushReplacement(
      MaterialPageRoute(
        builder: (_) => WebRTCCallScreen(
          remoteUserId: widget.remoteUserId,
          remoteUserName: widget.remoteUserName,
          remoteUserAvatar: widget.remoteUserAvatar,
          isOutgoingCall: true,
        ),
      ),
    );
  }

  void _initPulseAnimation() {
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    )..repeat(reverse: true);
  }

  Future<void> _startCall() async {
    // Start WebRTC call
    final success = await _webrtcService.startCall(
      remoteUserId: widget.remoteUserId,
      remoteUserName: widget.remoteUserName,
      remoteUserAvatar: widget.remoteUserAvatar,
    );

    if (!success && mounted) {
      _endCall("Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu cu·ªôc g·ªçi");
    }
  }

  /// Ki·ªÉm tra partner c√≥ online kh√¥ng
  void _checkPartnerOnline() {
    _offlineCheckTimer = Timer(const Duration(seconds: 5), () {
      // TODO: Check via Socket.IO if partner is online
      // N·∫øu offline: _endCall("Ng∆∞·ªùi d√πng kh√¥ng tr·ª±c tuy·∫øn")
    });
  }

  /// Timeout 3 ph√∫t (180 gi√¢y) - Messenger standard
  void _startTimeoutTimer() {
    _timeoutTimer = Timer(const Duration(seconds: 180), () {
      if (mounted && !_hasEnded) {
        _endCall("Ng∆∞·ªùi d√πng kh√¥ng li√™n l·∫°c ƒë∆∞·ª£c");
      }
    });
  }

  void _endCall(String reason) {
    if (_hasEnded) return;
    
    print('\n‚è±Ô∏è [OUTGOING] Ending call: $reason');
    _webrtcService.endCall(sendNotification: true);
    
    if (!mounted) return;
    
    setState(() {
      _hasEnded = true;
    });
    
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      Navigator.of(context).pop();
      print('‚úÖ [OUTGOING] Screen dismissed after timeout/end\n');
    });
  }

  void _cancelCall() {
    if (_hasEnded) return;
    
    print('\n‚ùå [OUTGOING] User cancelling call');
    
    if (!mounted) return;
    
    setState(() {
      _hasEnded = true;
    });

    _webrtcService.endCall(sendNotification: true);
    
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      Navigator.of(context).pop();
      print('‚úÖ [OUTGOING] Screen dismissed after cancel\n');
    });
  }

  @override
  void dispose() {
    _pulseController.dispose();
    _timeoutTimer?.cancel();
    _offlineCheckTimer?.cancel();
    _callStateSub?.cancel();
    _answerSub?.cancel();
    _rejectedSub?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      onWillPop: () async {
        // N·∫øu cu·ªôc g·ªçi ƒë√£ k·∫øt th√∫c (b·ªã reject/cancel/timeout), cho ph√©p pop
        if (_hasEnded) {
          return true; // Cho ph√©p dismiss
        }
        // N·∫øu ch∆∞a ended, user ƒëang c·ªë tho√°t th√¨ cancel call
        _cancelCall();
        return false; // Kh√¥ng cho dismiss ngay, ch·ªù cancel xong
      },
      child: Scaffold(
        backgroundColor: Colors.black,
        body: SafeArea(
          child: Stack(
            children: [
              // Gradient background
              Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [
                      Colors.blue.shade900.withOpacity(0.8),
                      Colors.black,
                    ],
                  ),
                ),
              ),

              // Main content
              Column(
                children: [
                  const SizedBox(height: 80),

                  // Avatar v·ªõi pulse animation
                  AnimatedBuilder(
                    animation: _pulseController,
                    builder: (context, child) {
                      return Container(
                        width: 160 + (_pulseController.value * 20),
                        height: 160 + (_pulseController.value * 20),
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: Colors.blue.withOpacity(0.3),
                              blurRadius: 30 + (_pulseController.value * 10),
                              spreadRadius: 10,
                            ),
                          ],
                        ),
                        child: CircleAvatar(
                          radius: 80,
                          backgroundImage: widget.remoteUserAvatar != null &&
                                  widget.remoteUserAvatar!.isNotEmpty
                              ? NetworkImage(widget.remoteUserAvatar!)
                              : const AssetImage('assets/images/default_avatar.png') as ImageProvider,
                          backgroundColor: Colors.blue.shade700,
                        ),
                      );
                    },
                  ),

                  const SizedBox(height: 40),

                  // T√™n ng∆∞·ªùi nh·∫≠n
                  Text(
                    widget.remoteUserName,
                    style: GoogleFonts.roboto(
                      fontSize: 32,
                      fontWeight: FontWeight.bold,
                      color: Colors.white,
                    ),
                  ),

                  const SizedBox(height: 12),

                  // Status text v·ªõi animation
                  AnimatedSwitcher(
                    duration: const Duration(milliseconds: 300),
                    child: Text(
                      _statusText,
                      key: ValueKey(_statusText),
                      style: GoogleFonts.roboto(
                        fontSize: 18,
                        color: Colors.white70,
                      ),
                    ),
                  ),

                  const SizedBox(height: 20),

                  // Loading indicator
                  const SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white70),
                    ),
                  ),

                  const Spacer(),

                  // End Call Button (M√†u ƒë·ªè, to, gi·ªëng Messenger)
                  Padding(
                    padding: const EdgeInsets.only(bottom: 80),
                    child: Column(
                      children: [
                        // N√∫t End Call ch√≠nh
                        GestureDetector(
                          onTap: _cancelCall,
                          child: Container(
                            width: 70,
                            height: 70,
                            decoration: BoxDecoration(
                              color: Colors.red,
                              shape: BoxShape.circle,
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.red.withOpacity(0.5),
                                  blurRadius: 20,
                                  spreadRadius: 5,
                                ),
                              ],
                            ),
                            child: const Icon(
                              Icons.call_end,
                              color: Colors.white,
                              size: 32,
                            ),
                          ),
                        ),
                        const SizedBox(height: 12),
                        Text(
                          'H·ªßy',
                          style: GoogleFonts.roboto(
                            fontSize: 16,
                            color: Colors.white,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
